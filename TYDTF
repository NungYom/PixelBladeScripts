-- Executor-safe GUI Parent
local guiParent = gethui and gethui() or game:FindFirstChild("CoreGui") or game.Players.LocalPlayer:WaitForChild("PlayerGui")

-- Clear GUI ก่อน (กันซ้อน)
if guiParent:FindFirstChild("ExecutorUI") then
    guiParent:FindFirstChild("ExecutorUI"):Destroy()
end

-- สร้าง GUI
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "ExecutorUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = guiParent

-- ป้ายสถานะ
local statusLabel = Instance.new("TextLabel")
statusLabel.Size = UDim2.new(0, 200, 0, 30)
statusLabel.Position = UDim2.new(0, 20, 0, 0)
statusLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
statusLabel.TextColor3 = Color3.new(1, 1, 1)
statusLabel.Font = Enum.Font.SourceSansBold
statusLabel.TextSize = 20
statusLabel.Text = "สถานะ: หยุดทั้งหมด"
statusLabel.Parent = ScreenGui

-- ฟังก์ชันสร้างปุ่ม
local function createButton(name, posY, color, callback)
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(0, 150, 0, 40)
	btn.Position = UDim2.new(0, 20, 0, posY)
	btn.Text = name .. " [OFF]"
	btn.BackgroundColor3 = color
	btn.TextColor3 = Color3.new(1, 1, 1)
	btn.Font = Enum.Font.SourceSansBold
	btn.TextSize = 20
	btn.Parent = ScreenGui
	btn.MouseButton1Click:Connect(function()
		callback(btn)
	end)
	return btn
end

-- ========== StartLoop ==========
local isLooping = false
local loopThread

local function startInvokeLoop()
	loopThread = coroutine.create(function()
		while isLooping do
			for i = 1, 11 do
				if not isLooping then break end
				local args = {
					"\233\162\134\229\143\150\229\156\168\231\186\191\229\165\150\229\138\177",
					i
				}
				pcall(function()
					game:GetService("ReplicatedStorage"):WaitForChild("Msg"):WaitForChild("RemoteFunction"):InvokeServer(unpack(args))
				end)
				wait(1)
			end
		end
	end)
	coroutine.resume(loopThread)
end

local btnStart = createButton("StartLoop", 0.07, Color3.fromRGB(60, 180, 75), function(btn)
	isLooping = not isLooping
	btn.Text = "StartLoop [" .. (isLooping and "ON" or "OFF") .. "]"
	statusLabel.Text = "สถานะ: " .. (isLooping and "StartLoop ทำงาน" or "หยุด StartLoop")
	if isLooping then
		startInvokeLoop()
	end
end)

-- ========== Loop Kill ==========
local isKilling = false
local killThread

local function getClosestPlayer(radius)
	local lp = game.Players.LocalPlayer
	local char = lp.Character
	if not (char and char:FindFirstChild("HumanoidRootPart")) then return nil end

	local myPos = char.HumanoidRootPart.Position
	local closest = nil
	local minDist = radius

	for _, p in ipairs(game.Players:GetPlayers()) do
		if p ~= lp and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
			local dist = (p.Character.HumanoidRootPart.Position - myPos).Magnitude
			if dist < minDist then
				minDist = dist
				closest = p
			end
		end
	end

	return closest
end

local function startKillLoop()
	killThread = coroutine.create(function()
		while isKilling do
			pcall(function()
				local target = getClosestPlayer(100)
				if target then
					local args = {
						"\231\142\169\229\174\182\233\128\137\230\139\169\231\155\174\230\160\135",
						{ target }
					}
					game:GetService("ReplicatedStorage"):WaitForChild("Msg"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
					statusLabel.Text = "Loop Kill กำลังโจมตี: " .. target.Name
				else
					statusLabel.Text = "Loop Kill: ไม่พบเป้าหมาย"
				end
			end)
			wait(0.5)
		end
	end)
	coroutine.resume(killThread)
end

local btnKill = createButton("Loop Kill", 0.14, Color3.fromRGB(80, 80, 220), function(btn)
	isKilling = not isKilling
	btn.Text = "Loop Kill [" .. (isKilling and "ON" or "OFF") .. "]"
	statusLabel.Text = "สถานะ: " .. (isKilling and "Loop Kill ทำงาน" or "หยุด Loop Kill")
	if isKilling then
		startKillLoop()
	end
end)
